<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>ニコリタウン - ルーム（音声/カメラ/画面共有 + ホワイトボード）</title>
<style>
  :root{--bg:#0b1220;--panel2:#101826;--border:#334155;--text:#e2e8f0;--muted:#9aa6b2;--a1:#22d3ee;--a2:#06b6d4;--yellow:#fde68a33;--yellowBorder:#facc15;--mention:#22d3ee}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;overflow:hidden;touch-action:none}
  #game{display:block;width:100vw;height:100vh;image-rendering:pixelated}

  /* HUD */
  .hud{position:fixed;left:8px;top:8px;display:flex;gap:8px;align-items:center;z-index:20}
  .hud .info{background:var(--panel2);border:1px solid var(--border);padding:6px 10px;border-radius:10px}
  .hud button{font:inherit;padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:linear-gradient(180deg,var(--a1),var(--a2));color:#06202a;font-weight:700;cursor:pointer}

  /* Chat */
  #chatView{position:fixed;right:8px;top:8px;z-index:20;width:min(36vw,520px);max-height:55vh;overflow:auto;background:rgba(16,24,38,.85);backdrop-filter:blur(6px);border:1px solid var(--border);border-radius:12px;padding:8px}
  #chatView .item{padding:6px 8px;border-radius:8px;margin:6px 0;position:relative}
  #chatView .me{background:rgba(34,211,238,.12)}
  #chatView .replyTo{display:block;font-size:.85rem;color:var(--muted);background:rgba(148,163,184,.12);padding:4px 6px;border-left:3px solid #64748b;border-radius:6px;margin-bottom:4px;cursor:pointer}
  .replyToMe{background:var(--yellow); border:1px solid var(--yellowBorder)}
  .mentionSelf{color:var(--mention);font-weight:700}
  .meta{color:var(--muted);font-size:.8rem;margin-top:2px}

  /* Composer */
  #composer{position:fixed;left:50%;bottom:8px;transform:translateX(-50%);display:flex;gap:6px;z-index:20;background:var(--panel2);border:1px solid var(--border);border-radius:12px;padding:6px}
  #composer input{font:inherit;width:min(60vw,720px);padding:10px 12px;border:1px solid var(--border);border-radius:10px;background:#0b1220;color:#e2e8f0}
  #composer button{font:inherit;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:linear-gradient(180deg,var(--a1),var(--a2));color:#06202a;font-weight:700;cursor:pointer}

  /* Ctx menu */
  #ctxMenu{position:fixed;z-index:50;display:none;background:#101826;border:1px solid var(--border);border-radius:10px;overflow:hidden}
  #ctxMenu button{display:block;width:200px;text-align:left;padding:10px 12px;background:transparent;border:0;color:#e2e8f0;cursor:pointer}
  #ctxMenu button:hover{background:#1b2540}

  /* Reaction */
  #reactFab{position:fixed;right:16px;bottom:96px;z-index:24;width:56px;height:56px;border-radius:50%;display:grid;place-items:center;font-size:22px;border:1px solid var(--border);background:linear-gradient(180deg,var(--a1),var(--a2));color:#06202a;box-shadow:0 8px 22px rgba(0,0,0,.35)}
  #reactMenu{position:fixed;right:16px;bottom:160px;z-index:25;display:none;background:#101826;border:1px solid var(--border);border-radius:12px;padding:6px}
  #reactMenu button{font-size:22px;line-height:1.2;padding:6px 8px;background:transparent;border:0;cursor:pointer}
  .bubble{position:absolute;transform:translate(-50%,-100%);background:#101826;border:1px solid var(--border);border-radius:12px;padding:6px 10px;font-size:20px}

  /* Joystick (mobile) */
  #joyBase{position:fixed;left:16px;bottom:96px;z-index:23;width:108px;height:108px;border-radius:50%;border:1px solid var(--border);background:rgba(15,23,42,.6);display:none;touch-action:none}
  #joyStick{position:absolute;left:50%;top:50%;width:52px;height:52px;border-radius:50%;transform:translate(-50%,-50%);border:1px solid var(--border);background:linear-gradient(180deg,var(--a1),var(--a2));color:#06202a}

  /* === Voice/Video UI === */
  #avBar{position:fixed;left:8px;top:72px;z-index:26;display:flex;gap:6px}
  #avBar button{font:inherit;padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:#0f172a;color:#e2e8f0}
  #avBar button.on{background:linear-gradient(180deg,var(--a1),var(--a2));color:#06202a;border:0}
  #videos{position:fixed;left:8px;top:120px;z-index:26;display:flex;flex-wrap:wrap;gap:6px;max-width:32vw}
  #videos video{width:160px;height:96px;object-fit:cover;border-radius:10px;border:1px solid var(--border);background:#000}
  #videos .label{position:absolute;background:rgba(0,0,0,.55);font-size:12px;padding:2px 6px;border-radius:6px;color:#e2e8f0;margin:4px}
  .vidWrap{position:relative}

  /* === Whiteboard === */
  .boardPin{position:absolute; width:28px; height:20px; background:#0ea5e9; color:#031b2a; border:1px solid var(--border); border-radius:4px; display:grid; place-items:center; font-weight:700}
  #wbModal{position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:40}
  #wbPanel{width:min(90vw,900px); background:#101826; border:1px solid var(--border); border-radius:12px; padding:12px}
  #wbTools{display:flex; gap:8px; align-items:center; margin-bottom:8px}
  #wbCanvas{width:100%; height:520px; background:#0b1220; border:1px solid var(--border); border-radius:8px; touch-action:none}
</style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud">
    <button id="leave" title="退室">退室</button>
    <div class="info">ルーム: <span id="roomId">-</span>／ 自分: <span id="who">-</span>／ 人数: <span id="count">0</span></div>
  </div>

  <div id="avBar">
    <button id="btnMic" title="マイク">🎙️</button>
    <button id="btnCam" title="カメラ">📷</button>
    <button id="btnShare" title="画面共有">🖥️</button>
  </div>
  <div id="videos"></div>

  <div id="chatView"></div>
  <div id="composer">
    <input id="text" placeholder="メッセージ…（@自分は水色 / 返信は右クリック）" maxlength="2000" />
    <button id="send">送信</button>
  </div>

  <div id="ctxMenu">
    <button id="ctxReply">返信</button>
    <button id="ctxReactOpen">リアクション</button>
    <button id="editMsg">編集</button>
    <button id="delMsg">削除</button>
  </div>

  <button id="reactFab" title="リアクション">😊</button>
  <div id="reactMenu"></div>

  <!-- Mobile joystick -->
  <div id="joyBase"><div id="joyStick"></div></div>

  <!-- Whiteboard modal -->
  <div id="wbModal">
    <div id="wbPanel">
      <div id="wbTools">
        <span>🧪 提案ホワイトボード</span>
        <label>色 <input type="color" id="wbColor" value="#22d3ee"></label>
        <label>太さ <input type="range" id="wbSize" min="2" max="18" value="6"></label>
        <button id="wbClear">全消し</button>
        <button id="wbClose">閉じる</button>
      </div>
      <canvas id="wbCanvas" width="1200" height="700"></canvas>
    </div>
  </div>

<script type="module">
/* ===== Params ===== */
const SCALE=6, SPEED_PPS=320, RADIUS=10, PLAYER_INTERP=12, CAM_INTERP=10, SYNC_MS=50, MAX_MSG=120, FRAME_MIN=1000/50;
const EMOJIS=['👍','❤️','😂','🎉','😮','🙏','🔥','😢'];

/* ===== Firebase ===== */
import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js';
import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js';
import { getDatabase, ref, onDisconnect, set, update, remove, onValue, push, limitToLast, query, onChildAdded, onChildChanged, onChildRemoved } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js';

const firebaseConfig={
  apiKey:'AIzaSyCy3P-HQhfd8-zpPUJ5YANxwRMuTCjFFAQ',
  authDomain:'nikori-town.firebaseapp.com',
  databaseURL:'https://nikori-town-default-rtdb.asia-southeast1.firebasedatabase.app',
  projectId:'nikori-town',
  storageBucket:'nikori-town.appspot.com',
  messagingSenderId:'836836010871',
  appId:'1:836836010871:web:74ae40cb16ee6d50368f72'
};
const app=initializeApp(firebaseConfig);
const auth=getAuth(app);
const db=getDatabase(app,'https://nikori-town-default-rtdb.asia-southeast1.firebasedatabase.app');

/* ===== Utilities ===== */
const $ = s=>document.querySelector(s);
function warn(msg){ let box=document.getElementById('warnBox'); if(!box){ box=document.createElement('div'); box.id='warnBox'; Object.assign(box.style,{position:'fixed',left:'8px',bottom:'8px',zIndex:9999,background:'#101826',color:'#facc15',border:'1px solid #334155',padding:'6px 10px',borderRadius:'8px',maxWidth:'60vw',fontSize:'12px'}); document.body.appendChild(box);} const p=document.createElement('div'); p.textContent=msg; box.appendChild(p);} 
const isTouch = matchMedia('(pointer: coarse)').matches || 'ontouchstart' in window || navigator.maxTouchPoints>0;

async function ensureAnonAuth(auth){ if(auth.currentUser) return auth.currentUser; await signInAnonymously(auth); return await new Promise(r=>{const stop=onAuthStateChanged(auth,u=>{ if(u){ stop(); r(u);} });}); }

/* ===== URL ===== */
const u=new URL(location.href);
const ROOM=(u.searchParams.get('room')||'room-001').trim().toLowerCase().replace(/[.#$/\[\]\/]/g,'-').slice(0,32);
const NAME=u.searchParams.get('name')||'guest';
roomId.textContent=ROOM; who.textContent=NAME;

/* ===== Assets ===== */
function loadImage(src, {fallbackSize=[2048,2048], label='asset'}={}){return new Promise((res)=>{const i=new Image(); i.onload=()=>res(i); i.onerror=()=>{try{const c=document.createElement('canvas'); c.width=fallbackSize[0]; c.height=fallbackSize[1]; const g=c.getContext('2d'); g.fillStyle='#0f172a'; g.fillRect(0,0,c.width,c.height); g.fillStyle='#334155'; g.fillText(label,10,20); const img=new Image(); img.onload=()=>res(img); img.src=c.toDataURL();}catch{const img=new Image(); img.src='data:image/gif;base64,R0lGODlhAQABAAAAACw='; img.onload=()=>res(img);} }; i.src=src;});}
const imgMap = await loadImage('./map_1.png?v=20250928-1',{fallbackSize:[2048,2048],label:'map'});
const imgMask= await loadImage('./atarihantei.png?v=20250928-1',{fallbackSize:[2048,2048],label:'mask'});
const imgFront=await loadImage('./nikorihito_dot_front.png?v=20250928-1');
const imgBack =await loadImage('./nikorihito_dot_behind.png?v=20250928-1');
const imgLeft =await loadImage('./nikorihito_dot_left.png?v=20250928-1');
const imgRight=await loadImage('./nikorihito_dot_right.png?v=20250928-1');

/* ===== Canvas & world ===== */
const canvas=$('#game'); const ctx=canvas.getContext('2d'); ctx.imageSmoothingEnabled=false;
function resize(){canvas.width=innerWidth; canvas.height=innerHeight;} addEventListener('resize',resize); resize();
const world={w:imgMap.width,h:imgMap.height};

/* ===== Collision ===== */
const maskCanvas=(typeof OffscreenCanvas!=='undefined')?new OffscreenCanvas(imgMask.width,imgMask.height):Object.assign(document.createElement('canvas'),{width:imgMask.width,height:imgMask.height});
const mctx=maskCanvas.getContext('2d'); mctx.drawImage(imgMask,0,0);
const mdata=mctx.getImageData(0,0,imgMask.width,imgMask.height); const mpix=mdata.data; const MW=imgMask.width;
function isBlocked(x,y){x=x|0; y=y|0; if(x<0||y<0||x>=world.w||y>=world.h) return true; const i=(y*MW+x)*4; const r=mpix[i], g=mpix[i+1], b=mpix[i+2], a=mpix[i+3]; if(a<10) return false; return (r>=180 && g<=80 && b<=80);} // 赤っぽい
function hits(x,y){const foot=y+(RADIUS*0.6); return isBlocked(x,foot)||isBlocked(x-RADIUS*0.7,foot)||isBlocked(x+RADIUS*0.7,foot);} 
function safeSpawn(maxTry=400){for(let i=0;i<maxTry;i++){const x=Math.random()*(world.w-64)+32, y=Math.random()*(world.h-64)+32; if(!hits(x,y)) return {x,y};} const cx=world.w/2, cy=world.h/2; return {x:cx,y:cy};}

/* ===== Players ===== */
const playersRef=ref(db,`rooms/${ROOM}/players`);
const meId=(crypto.randomUUID?crypto.randomUUID():(`m${Math.random().toString(36).slice(2)}`));
const meRef=ref(db,`rooms/${ROOM}/players/${meId}`);
let my=Object.assign({name:NAME,dir:'front',ts:Date.now()}, safeSpawn());
await ensureAnonAuth(auth); await set(meRef,my); onDisconnect(meRef).remove().catch(()=>{});
let players={}; const ghosts={};
onValue(playersRef,snap=>{players=snap.val()||{}; count.textContent=Object.keys(players).length; for(const [id,p] of Object.entries(players)){ if(!ghosts[id]&&p) ghosts[id]={x:p.x,y:p.y,dir:p.dir,name:p.name}; }});

/* ===== Chat（mention / reply） ===== */
const chatRef=ref(db,`rooms/${ROOM}/chat`);
const chatView=$('#chatView'); const textEl=$('#text'); const sendBtn=$('#send');
const ctxMenu=$('#ctxMenu'); let ctxTargetId=null; let replyToMsgId=null; const items=new Map(); const msgIndex=new Map();
function openCtx(x,y){ctxMenu.style.display='block'; ctxMenu.style.left=x+'px'; ctxMenu.style.top=y+'px';}
function closeCtx(){ctxMenu.style.display='none'; ctxTargetId=null;} addEventListener('click',()=>closeCtx());
function highlightMentions(container, text){const meTag='@'+NAME; const parts=(text||'').split(/(@[^\s]+)/g); for(const part of parts){ if(part===meTag){ const span=document.createElement('span'); span.className='mentionSelf'; span.textContent=part; container.appendChild(span);} else { container.appendChild(document.createTextNode(part)); }}}
function messageEl(id,m){ const el=document.createElement('div'); el.className='item'+(m.uid===meId?' me':''); el.dataset.id=id; el.dataset.uid=m.uid||''; if(m.replyTo){ const parent=msgIndex.get(m.replyTo); const r=document.createElement('div'); r.className='replyTo'; r.textContent= parent ? `↪ ${parent.name||'someone'} さんのメッセージ` : '↪ （元メッセージ）'; r.onclick=()=>{ const tgt=items.get(m.replyTo); if(tgt){ tgt.scrollIntoView({behavior:'smooth',block:'center'}); }}; el.appendChild(r); if(parent && parent.uid===meId) el.classList.add('replyToMe'); } const line=document.createElement('div'); highlightMentions(line, m.text||''); el.appendChild(line); const meta=document.createElement('div'); meta.className='meta'; meta.textContent=new Date(m.ts||Date.now()).toLocaleString(); el.appendChild(meta); el.oncontextmenu=(e)=>{ e.preventDefault(); ctxTargetId=id; openCtx(e.clientX,e.clientY); }; let pressTimer; el.addEventListener('touchstart',e=>{ pressTimer=setTimeout(()=>{ ctxTargetId=id; const t=e.touches[0]; openCtx(t.clientX,t.clientY); },600); }); el.addEventListener('touchend',()=>clearTimeout(pressTimer)); return el; }
const chatQ=query(chatRef,limitToLast(MAX_MSG));
onChildAdded(chatQ,s=>{ const id=s.key,m=s.val()||{}; msgIndex.set(id,m); const el=messageEl(id,m); items.set(id,el); chatView.appendChild(el); chatView.scrollTop=chatView.scrollHeight; });
onChildChanged(chatQ,s=>{ const id=s.key,m=s.val()||{}; msgIndex.set(id,m); const old=items.get(id); if(old){ const el=messageEl(id,m); chatView.replaceChild(el,old); items.set(id,el);} });
onChildRemoved(chatQ,s=>{ const id=s.key; const el=items.get(id); if(el){ el.remove(); items.delete(id);} msgIndex.delete(id); });
async function sendMessage(payload){ await push(chatRef, Object.assign({uid:meId,name:NAME,ts:Date.now()}, payload)); }
$('#ctxReply').onclick=()=>{ if(!ctxTargetId) return; replyToMsgId=ctxTargetId; closeCtx(); textEl.focus(); };
$('#ctxReactOpen').onclick=()=>{ closeCtx(); openReactMenu(); };
$('#editMsg').onclick=async()=>{ if(!ctxTargetId) return; const old=items.get(ctxTargetId); const cur=old?.querySelector('div')?.textContent||''; const t=prompt('メッセージを編集',cur); if(t==null) return; await update(ref(db,`rooms/${ROOM}/chat/${ctxTargetId}`), { text:t.slice(0,2000), edited:true, ts:Date.now() }); closeCtx(); };
$('#delMsg').onclick=async()=>{ if(!ctxTargetId) return; await remove(ref(db,`rooms/${ROOM}/chat/${ctxTargetId}`)); closeCtx(); };
let sending=false; sendBtn.onclick=async()=>{ if(sending) return; const text=textEl.value.trim(); if(!text) return; sending=true; try{ const msg={ text:text.slice(0,2000) }; if(replyToMsgId){ msg.replyTo=replyToMsgId; replyToMsgId=null; } await sendMessage(msg); textEl.value=''; } finally { sending=false; } };
textEl.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); sendBtn.click(); } });

/* ===== Reactions ===== */
const bubblesRef=ref(db,`rooms/${ROOM}/bubbles`);
const reactFab=$('#reactFab'); const reactMenu=$('#reactMenu');
function openReactMenu(){ reactMenu.innerHTML=''; EMOJIS.forEach(e=>{ const b=document.createElement('button'); b.textContent=e; b.onclick=()=>{ push(bubblesRef,{uid:meId,emoji:e,ts:Date.now()}); reactMenu.style.display='none'; }; reactMenu.appendChild(b); }); reactMenu.style.display='block'; }
reactFab.onclick=()=>{ reactMenu.style.display=(reactMenu.style.display==='block')?'none':'block'; if(reactMenu.style.display==='block') openReactMenu(); };
const bubbles=new Map();
function showBubbleFor(uid,emoji){ let b=bubbles.get(uid); if(!b){ b=document.createElement('div'); b.className='bubble'; document.body.appendChild(b); bubbles.set(uid,b); } b.textContent=emoji; b.style.display='block'; clearTimeout(b._t); b._t=setTimeout(()=>{ b.style.display='none'; },1800); }
onChildAdded(query(bubblesRef,limitToLast(50)), s=>{ const {uid,emoji,ts}=s.val()||{}; if(!uid||!emoji) return; if(Date.now()-ts>5000) return; showBubbleFor(uid,emoji); });

/* ===== Camera & Render ===== */
function spriteByDir(d){return d==='back'?imgBack:d==='left'?imgLeft:d==='right'?imgRight:imgFront;}
let camX=0, camY=0; function camera(dt){const tx=Math.round(my.x-canvas.width/2), ty=Math.round(my.y-canvas.height/2); const k=Math.min(1,dt*CAM_INTERP); camX+=(tx-camX)*k; camY+=(ty-camY)*k; camX=Math.max(0,Math.min(world.w-canvas.width,camX)); camY=Math.max(0,Math.min(world.h-canvas.height,camY)); return {x:camX,y:camY};}

/* ===== Input: keys & joystick ===== */
const keys=new Set();
const isTyping = (el) => el && (el.tagName==='INPUT' || el.isContentEditable);
addEventListener('keydown',e=>{ if(isTyping(e.target)) return; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault(); keys.add(e.key); });
addEventListener('keyup',e=>{ if(isTyping(e.target)) return; keys.delete(e.key); });
const joyBase=$('#joyBase'), joyStick=$('#joyStick'); let joyVec={x:0,y:0}, joyActive=false;
if(isTouch){ joyBase.style.display='block'; const getVec=(cx,cy)=>{ const rect=joyBase.getBoundingClientRect(); const ox=rect.left+rect.width/2, oy=rect.top+rect.height/2; let dx=cx-ox, dy=cy-oy; const len=Math.hypot(dx,dy); const limit=rect.width/2-10; if(len>limit){ dx=dx*limit/len; dy=dy*limit/len; } joyStick.style.transform=`translate(${dx}px,${dy}px) translate(-50%,-50%)`; return {x:dx/limit, y:dy/limit}; }; const start=e=>{ joyActive=true; const t=e.touches?e.touches[0]:e; joyVec=getVec(t.clientX,t.clientY); }; const move=e=>{ if(!joyActive) return; const t=e.touches?e.touches[0]:e; joyVec=getVec(t.clientX,t.clientY); }; const end=()=>{ joyActive=false; joyVec={x:0,y:0}; joyStick.style.transform='translate(-50%,-50%)'; }; joyBase.addEventListener('pointerdown',start); joyBase.addEventListener('pointermove',move); joyBase.addEventListener('pointerup',end); joyBase.addEventListener('pointercancel',end); joyBase.addEventListener('touchstart',start,{passive:false}); joyBase.addEventListener('touchmove',move,{passive:false}); joyBase.addEventListener('touchend',end); }

/* ===== Whiteboard (boards) ===== */
const boardsRef = ref(db, `rooms/${ROOM}/boards`);
let boards = {}; onValue(boardsRef, s=>{ boards = s.val()||{}; });

// Board pins rendering (in world coords)
function drawBoards(cam){ for(const [bid,b] of Object.entries(boards)){ if(!b) continue; const sx=Math.round((b.x||0)-cam.x), sy=Math.round((b.y||0)-cam.y-40); ctx.save(); ctx.fillStyle='#0ea5e9'; ctx.strokeStyle='#083344'; ctx.lineWidth=2; ctx.fillRect(sx-14, sy-10, 28, 20); ctx.strokeRect(sx-14, sy-10, 28, 20); ctx.fillStyle='#022c22'; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.fillText('H', sx, sy+4); ctx.restore(); } }

// Open whiteboard modal when near a board and press Enter, or immediately after placing
const wbModal = $('#wbModal'), wbCanvas = $('#wbCanvas'), wbCtx = wbCanvas.getContext('2d');
const wbColor = $('#wbColor'), wbSize = $('#wbSize');
let activeBoardId = null; let drawing = false; let lastPt = null;

function openBoard(bid){ activeBoardId=bid; wbModal.style.display='flex'; wbCtx.clearRect(0,0,wbCanvas.width, wbCanvas.height); // load strokes
  onValue(ref(db,`rooms/${ROOM}/boards/${bid}/strokes`), s=>{ wbCtx.clearRect(0,0,wbCanvas.width, wbCanvas.height); const strokes=s.val()||{}; for(const seg of Object.values(strokes)){ drawSeg(seg); } });
}
function closeBoard(){ wbModal.style.display='none'; activeBoardId=null; lastPt=null; drawing=false; }
$('#wbClose').onclick=closeBoard; $('#wbClear').onclick=async()=>{ if(!activeBoardId) return; await remove(ref(db,`rooms/${ROOM}/boards/${activeBoardId}/strokes`)); };

function drawSeg(seg){ wbCtx.strokeStyle=seg.color||'#22d3ee'; wbCtx.lineWidth=seg.size||6; wbCtx.lineCap='round'; wbCtx.beginPath(); wbCtx.moveTo(seg.x0,seg.y0); wbCtx.lineTo(seg.x1,seg.y1); wbCtx.stroke(); }
function sendSeg(x0,y0,x1,y1){ if(!activeBoardId) return; const seg={x0,y0,x1,y1,color:wbColor.value,size:parseInt(wbSize.value)||6,ts:Date.now(),uid:meId}; push(ref(db,`rooms/${ROOM}/boards/${activeBoardId}/strokes`), seg); }
wbCanvas.addEventListener('pointerdown', e=>{ if(!activeBoardId) return; drawing=true; const r=wbCanvas.getBoundingClientRect(); lastPt={x:e.clientX-r.left, y:e.clientY-r.top}; });
wbCanvas.addEventListener('pointermove', e=>{ if(!drawing||!lastPt) return; const r=wbCanvas.getBoundingClientRect(); const p={x:e.clientX-r.left, y:e.clientY-r.top}; drawSeg({x0:lastPt.x,y0:lastPt.y,x1:p.x,y1:p.y,color:wbColor.value,size:parseInt(wbSize.value)||6}); sendSeg(lastPt.x,lastPt.y,p.x,p.y); lastPt=p; });
wbCanvas.addEventListener('pointerup', ()=>{ drawing=false; lastPt=null; });
wbCanvas.addEventListener('pointerleave', ()=>{ drawing=false; lastPt=null; });

// Place a board at current position (H key)
addEventListener('keydown', async (e)=>{ if(isTyping(e.target)) return; if(e.key==='h' || e.key==='H'){ const b = { x: my.x, y: my.y, by: meId, name: NAME, ts: Date.now() }; const { key } = await push(boardsRef, b); openBoard(key); } });

/* ===== WebRTC (voice/cam/screen) ===== */
const ICE = { iceServers:[ {urls:'stun:stun.l.google.com:19302'} ] }; // ※ TURNなし（0円運用）。繋がらない回線が一部あります。
const callsRef = ref(db, `rooms/${ROOM}/webrtc/calls`);
const candsRef = ref(db, `rooms/${ROOM}/webrtc/candidates`);
const peers = new Map(); // peerId -> {pc, streams, vids, unsub}

let camStream=null, micStream=null, screenStream=null;
const btnMic=$('#btnMic'), btnCam=$('#btnCam'), btnShare=$('#btnShare');
const videos=$('#videos');

function addVideo(stream, label){ const wrap=document.createElement('div'); wrap.className='vidWrap'; const lab=document.createElement('div'); lab.className='label'; lab.textContent=label; const v=document.createElement('video'); v.autoplay=true; v.playsInline=true; v.muted = (label==='自分' || label==='自分(画面)'); v.srcObject=stream; wrap.appendChild(v); wrap.appendChild(lab); videos.appendChild(wrap); return {wrap, video:v}; }
function removeVideosByLabel(label){ [...videos.querySelectorAll('.vidWrap')].forEach(w=>{const t=w.querySelector('.label')?.textContent; if(t===label) w.remove();}); }

async function enableMic(on){ if(on){ if(!micStream){ try{ micStream = await navigator.mediaDevices.getUserMedia({audio:true, video:false}); addVideo(micStream,'自分'); }catch(e){ warn('マイク取得失敗: '+e.message); btnMic.classList.remove('on'); return; } } } else { if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; removeVideosByLabel('自分'); } }
  // 送信更新
  for(const {pc} of peers.values()){ // add or remove audio sender
    const senders = pc.getSenders();
    const cur = senders.find(s=>s.track && s.track.kind==='audio');
    const track = micStream?.getAudioTracks()[0]||null;
    if(track){ if(cur){ await cur.replaceTrack(track); } else { pc.addTrack(track, micStream); } }
    else if(cur){ try{ await cur.replaceTrack(null); }catch{} }
  }
}

async function enableCam(on){ if(on){ if(!camStream){ try{ camStream = await navigator.mediaDevices.getUserMedia({video:true, audio:false}); addVideo(camStream,'自分(カメラ)'); }catch(e){ warn('カメラ取得失敗: '+e.message); btnCam.classList.remove('on'); return; } } } else { if(camStream){ camStream.getTracks().forEach(t=>t.stop()); camStream=null; removeVideosByLabel('自分(カメラ)'); } }
  for(const {pc} of peers.values()){ const senders = pc.getSenders(); const cur = senders.find(s=>s.track && s.track.kind==='video'); const track = (screenStream?.getVideoTracks()[0]) || (camStream?.getVideoTracks()[0]) || null; if(track){ if(cur){ await cur.replaceTrack(track); } else { pc.addTrack(track, camStream||screenStream); } } else if(cur){ try{ await cur.replaceTrack(null); }catch{} } }
}

async function enableShare(on){ if(on){ if(!('getDisplayMedia' in navigator.mediaDevices)){ warn('画面共有非対応ブラウザ'); btnShare.classList.remove('on'); return; } try{ screenStream = await navigator.mediaDevices.getDisplayMedia({video:true, audio:true}); addVideo(screenStream,'自分(画面)'); screenStream.getVideoTracks()[0].onended = ()=>{ btnShare.classList.remove('on'); enableShare(false); } }catch(e){ warn('画面共有失敗: '+e.message); btnShare.classList.remove('on'); return; } } else { if(screenStream){ screenStream.getTracks().forEach(t=>t.stop()); screenStream=null; removeVideosByLabel('自分(画面)'); } }
  // 画面優先: video sender を差し替え
  for(const {pc} of peers.values()){ const senders = pc.getSenders(); const cur = senders.find(s=>s.track && s.track.kind==='video'); const track = (screenStream?.getVideoTracks()[0]) || (camStream?.getVideoTracks()[0]) || null; if(track){ if(cur){ await cur.replaceTrack(track); } else { pc.addTrack(track, screenStream||camStream); } } else if(cur){ try{ await cur.replaceTrack(null); }catch{} } }
}

btnMic.onclick = async()=>{ btnMic.classList.toggle('on'); await enableMic(btnMic.classList.contains('on')); };
btnCam.onclick = async()=>{ btnCam.classList.toggle('on'); await enableCam(btnCam.classList.contains('on')); };
btnShare.onclick = async()=>{ btnShare.classList.toggle('on'); await enableShare(btnShare.classList.contains('on')); };

function callKey(a,b){ return (a<b)?`${a}_${b}`:`${b}_${a}`; }

function createPC(peerId){ const pc=new RTCPeerConnection(ICE);
  // attach local tracks if available
  const vTrack = (screenStream?.getVideoTracks()[0]) || (camStream?.getVideoTracks()[0]);
  const aTrack = (micStream?.getAudioTracks()[0]);
  if(vTrack) pc.addTrack(vTrack, screenStream||camStream);
  if(aTrack) pc.addTrack(aTrack, micStream);
  pc.onicecandidate = (e)=>{ if(e.candidate){ push(ref(db,`rooms/${ROOM}/webrtc/candidates/${meId}/${peerId}`), e.candidate.toJSON()); } };
  pc.ontrack = (e)=>{ const stream = e.streams[0]; // 1 stream
    // if not shown, add video element
    let wrap = videos.querySelector(`[data-peer="${peerId}"]`);
    if(!wrap){ const w=document.createElement('div'); w.className='vidWrap'; w.dataset.peer=peerId; const lab=document.createElement('div'); lab.className='label'; lab.textContent= players[peerId]?.name || '相手'; const v=document.createElement('video'); v.autoplay=true; v.playsInline=true; v.srcObject=stream; w.appendChild(v); w.appendChild(lab); videos.appendChild(w); }
  };
  return pc;
}

async function ensurePeer(peerId){ if(peers.has(peerId)) return peers.get(peerId); const pc=createPC(peerId); const unsub = [];
  // candidates from them
  unsub.push( onChildAdded(ref(db,`rooms/${ROOM}/webrtc/candidates/${peerId}/${meId}`), s=>{ const c=s.val(); pc.addIceCandidate(new RTCIceCandidate(c)).catch(()=>{}); }) );
  peers.set(peerId,{pc,unsub}); return {pc,unsub}; }

// Establish calls when players list updates
onValue(playersRef, async s=>{
  const all = Object.keys(s.val()||{}).filter(id=>id!==meId);
  // close removed peers
  for(const id of [...peers.keys()]){ if(!all.includes(id)){ const {pc,unsub}=peers.get(id)||{}; try{pc.close();}catch{}; (unsub||[]).forEach(f=>typeof f==='function'&&f()); peers.delete(id); const wrap=videos.querySelector(`[data-peer="${id}"]`); wrap&&wrap.remove(); } }
  // connect new peers
  for(const pid of all){ await connectPair(pid); }
});

async function connectPair(peerId){ const key=callKey(meId, peerId); const iAmCaller = meId < peerId; const {pc} = await ensurePeer(peerId);
  if(iAmCaller){ // create offer once
    const offerRef = ref(db,`rooms/${ROOM}/webrtc/calls/${key}/offer`);
    const ansRef   = ref(db,`rooms/${ROOM}/webrtc/calls/${key}/answer`);
    const snap = await (await import('https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js')).get(offerRef).catch(()=>null);
    if(!snap || !snap.exists()){ const offer = await pc.createOffer(); await pc.setLocalDescription(offer); await set(offerRef,{sdp:offer.sdp,type:offer.type,from:meId,ts:Date.now()}); }
    // wait answer
    onValue(ansRef, async s=>{ const v=s.val(); if(v && pc.signalingState!=='stable'){ try{ await pc.setRemoteDescription(new RTCSessionDescription(v)); }catch{} } });
    // watch for offer change (reconnect)
  } else {
    // callee: wait offer -> answer
    const offerRef = ref(db,`rooms/${ROOM}/webrtc/calls/${key}/offer`);
    const ansRef   = ref(db,`rooms/${ROOM}/webrtc/calls/${key}/answer`);
    onValue(offerRef, async s=>{ const v=s.val(); if(!v) return; if(pc.currentRemoteDescription) return; try{ await pc.setRemoteDescription(new RTCSessionDescription(v)); const answer=await pc.createAnswer(); await pc.setLocalDescription(answer); await set(ansRef,{sdp:answer.sdp,type:answer.type,from:meId,ts:Date.now()}); }catch(e){ /* ignore */ } });
  }
}

/* ===== Main loop ===== */
let lastSync=0, selfLastX=my.x, selfLastY=my.y, selfLastDir=my.dir; let lastT=performance.now();
function step(now){ if(now-lastT<FRAME_MIN){requestAnimationFrame(step); return;} const dt=Math.min(0.05,(now-lastT)/1000); lastT=now; let vx=0, vy=0; if(keys.has('ArrowUp')) vy-=1; if(keys.has('ArrowDown')) vy+=1; if(keys.has('ArrowLeft')) vx-=1; if(keys.has('ArrowRight')) vx+=1; vx+=joyVec.x; vy+=joyVec.y; if(vx||vy){ const len=Math.hypot(vx,vy); vx/=len; vy/=len; const s=SPEED_PPS*dt; const nx=my.x+vx*s, ny=my.y+vy*s; if(!hits(nx,my.y)) my.x=nx; if(!hits(my.x,ny)) my.y=ny; my.dir=Math.abs(vx)>Math.abs(vy)?(vx>0?'right':'left'):(vy>0?'front':'back'); }
  const cam=camera(dt); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(imgMap, cam.x, cam.y, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
  // boards pins
  drawBoards(cam);
  // others
  const kInterp=Math.min(1,dt*PLAYER_INTERP); for(const [id,p] of Object.entries(players)){ if(!p||id===meId) continue; const g=(ghosts[id]||={x:p.x,y:p.y,dir:p.dir,name:p.name}); g.x+=(p.x-g.x)*kInterp; g.y+=(p.y-g.y)*kInterp; g.dir=p.dir||g.dir; const im=spriteByDir(g.dir||'front'); const sw=im.width*SCALE, sh=im.height*SCALE; ctx.drawImage(im, Math.round(g.x-sw/2-cam.x), Math.round(g.y-sh/2-cam.y), sw, sh); drawName(g.name||'?', g.x-cam.x, (g.y-sh/2)-cam.y-2,false); }
  // self
  const meIm=spriteByDir(my.dir), mw=meIm.width*SCALE, mh=meIm.height*SCALE; ctx.drawImage(meIm, Math.round(my.x-mw/2-cam.x), Math.round(my.y-mh/2-cam.y), mw, mh); drawName(NAME,my.x-cam.x,(my.y-mh/2)-cam.y-2,true);
  // bubbles position update
  for(const [uid,b] of bubbles){ const p = uid===meId ? my : (players[uid]||ghosts[uid]); if(!p||b.style.display==='none') continue; const x=(p.x||0)-cam.x, y=(p.y||0)-cam.y; b.style.left=x+'px'; b.style.top=(y - (mh/2) - 24)+'px'; }
  if(now-lastSync>SYNC_MS){ const dx=my.x-selfLastX, dy=my.y-selfLastY; const moved=(dx*dx+dy*dy)>1; const dirChanged=my.dir!==selfLastDir; if(moved||dirChanged){ lastSync=now; selfLastX=my.x; selfLastY=my.y; selfLastDir=my.dir; update(meRef,{x:my.x,y:my.y,dir:my.dir,ts:Date.now()}); } }
  requestAnimationFrame(step);
}
requestAnimationFrame(step);

/* ===== Name tag (simple big) ===== */
function drawName(name,x,y,me=false){ ctx.font = '20px system-ui, sans-serif'; ctx.textAlign = 'center'; ctx.fillStyle = 'rgba(0,0,0,.6)'; ctx.fillRect(x-60, y-28, 120, 32); ctx.fillStyle = me ? '#22d3ee' : '#e2e8f0'; ctx.fillText(name, x, y-8); }

/* 退室 */
document.getElementById('leave').onclick=()=>{ remove(meRef).finally(()=>{ location.href='./'; }); };
addEventListener('beforeunload', ()=>{ try{ remove(meRef); }catch{} });
</script>
</body>
</html>
