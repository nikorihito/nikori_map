<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ニコリタウン - ルーム</title>
<style>
  :root{--bg:#0b1220;--panel2:#101826;--border:#334155;--text:#e2e8f0;--muted:#9aa6b2;--a1:#22d3ee;--a2:#06b6d4}
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;overflow:hidden}
  #game{display:block;width:100vw;height:100vh;image-rendering:pixelated}
  .hud{position:fixed;left:8px;top:8px;display:flex;gap:8px;align-items:center;z-index:20}
  .hud button{font:inherit;padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:linear-gradient(180deg,var(--a1),var(--a2));color:#06202a;font-weight:700;cursor:pointer}
  .hud .info{background:var(--panel2);border:1px solid var(--border);padding:6px 10px;border-radius:10px}
  #chatView{position:fixed;right:8px;top:8px;z-index:20;width:min(36vw,520px);max-height:55vh;overflow:auto;background:rgba(16,24,38,.85);backdrop-filter:blur(6px);border:1px solid var(--border);border-radius:12px;padding:8px}
  #chatView .item{padding:4px 6px;border-radius:8px;margin:4px 0}
  #chatView .me{background:rgba(34,211,238,.15)}
  #composer{position:fixed;left:50%;bottom:8px;transform:translateX(-50%);display:flex;gap:6px;z-index:20;background:var(--panel2);border:1px solid var(--border);border-radius:12px;padding:6px}
  #composer input{font:inherit;width:min(60vw,720px);padding:8px 10px;border:1px solid var(--border);border-radius:10px;background:#0b1220;color:var(--text)}
  #composer button{font:inherit;padding:8px 12px;border-radius:10px;border:1px solid var(--border);background:linear-gradient(180deg,var(--a1),var(--a2));color:#06202a;font-weight:700;cursor:pointer}
  #ctxMenu{position:fixed;z-index:50;display:none;background:var(--panel2);border:1px solid var(--border);border-radius:10px;overflow:hidden}
  #ctxMenu button{display:block;width:180px;text-align:left;padding:8px 12px;background:transparent;border:0;color:var(--text);cursor:pointer}
  #ctxMenu button:hover{background:#1b2540}
</style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud">
    <button id="leave">退室</button>
    <div class="info">ルーム: <span id="roomId">-</span>／ 自分: <span id="who">-</span>／ 人数: <span id="count">0</span></div>
  </div>

  <div id="chatView"></div>
  <div id="composer">
    <input id="text" placeholder="メッセージ… (Enterで送信)" maxlength="200" />
    <button id="send">送信</button>
  </div>
  <div id="ctxMenu">
    <button id="editMsg">編集</button>
    <button id="delMsg">削除</button>
  </div>

<script type="module">
// ===== Firebase SDK =====
import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js';
import { getAuth, signInAnonymously } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js';
import { getDatabase, ref, onDisconnect, set, update, remove, onValue, push, limitToLast, query,
         onChildAdded, onChildChanged, onChildRemoved } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js';

const firebaseConfig = {
  apiKey: 'AIzaSyCy3P-HQhfd8-zpPUJ5YANxwRMuTCjFFAQ',
  authDomain: 'nikori-town.firebaseapp.com',
  databaseURL: 'https://nikori-town-default-rtdb.asia-southeast1.firebasedatabase.app',
  projectId: 'nikori-town',
  storageBucket: 'nikori-town.firebasestorage.app',
  messagingSenderId: '836836010871',
  appId: '1:836836010871:web:74ae40cb16ee6d50368f72'
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db   = getDatabase(app);

// ===== URL params =====
const u = new URL(location.href);
const ROOM = (u.searchParams.get('room')||'room-001').toLowerCase();
const NAME = u.searchParams.get('name')||'guest';
document.getElementById('roomId').textContent = ROOM;
document.getElementById('who').textContent    = NAME;

// ===== Assets =====
function loadImage(src){ return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=src; }); }
const imgMap   = await loadImage('./map_1.png');
const imgMask  = await loadImage('./atarihantei.png'); // 赤=壁
const imgFront = await loadImage('./nikorihito_dot_front.png');
const imgBack  = await loadImage('./nikorihito_dot_behind.png');
const imgLeft  = await loadImage('./nikorihito_dot_left.png');
const imgRight = await loadImage('./nikorihito_dot_right.png');

// ===== Canvas & Camera =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener('resize', resize); resize();

const world = { w: imgMap.width, h: imgMap.height };

// マスク（当たり判定）
const maskC = new OffscreenCanvas(imgMask.width, imgMask.height);
const maskX = maskC.getContext('2d');
maskX.drawImage(imgMask, 0, 0);
function isBlocked(x,y){
  if(x<0||y<0||x>=world.w||y>=world.h) return true;
  const d = maskX.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
  const r=d[0], g=d[1], b=d[2], a=d[3];
  if (a < 10) return false;
  return (r >= 180 && g <= 80 && b <= 80); // 赤
}

// ===== Game State =====
const SCALE  = 2.0;   // ★ キャラ描画2倍
const SPEED  = 20;   // px/frame
const RADIUS = 10;    // ★ あたり半径も上げる
let dir = 'front';
const keys = new Set();

// 安全スポーンを探す
function safeSpawn(maxTry=500){
  for(let i=0;i<maxTry;i++){
    const x = Math.random()*(world.w-64)+32;
    const y = Math.random()*(world.h-64)+32;
    if(!hits(x,y)) return {x,y};
  }
  // フォールバック：中央付近をスキャン
  const cx=world.w/2, cy=world.h/2;
  for(let r=0;r<400;r+=8){
    for(let a=0;a<Math.PI*2;a+=Math.PI/8){
      const x=cx+Math.cos(a)*r, y=cy+Math.sin(a)*r;
      if(!hits(x,y)) return {x,y};
    }
  }
  return {x: Math.max(16,Math.min(world.w-16,cx)), y: Math.max(16,Math.min(world.h-16,cy))};
}

let my = Object.assign({dir, name: NAME, ts: Date.now()}, safeSpawn());

// Firebase ノード
const playersRef = ref(db, `rooms/${ROOM}/players`);
const meId  = crypto.randomUUID();
const meRef = ref(db, `rooms/${ROOM}/players/${meId}`);
const chatRef = ref(db, `rooms/${ROOM}/chat`);

// 匿名Auth（ルールがauth必須でも動くように）
signInAnonymously(auth).catch(()=>{});

// 入室
await set(meRef, { name: NAME, x: my.x, y: my.y, dir: my.dir, ts: Date.now() });
onDisconnect(meRef).remove();

// 人数 & 他プレイヤー
let players = {};
onValue(playersRef, snap=>{
  players = snap.val()||{};
  document.getElementById('count').textContent = Object.keys(players).length;
});

// 入力
addEventListener('keydown', e=>{
  const k=e.key;
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(k)) e.preventDefault();
  keys.add(k);
});
addEventListener('keyup', e=>{ keys.delete(e.key); });

function spriteByDir(d){ return d==='back'?imgBack: d==='left'?imgLeft: d==='right'?imgRight: imgFront; }

// 円形近似の当たり
function hits(x,y){
  if(x<0||y<0||x>=world.w||y>=world.h) return true;
  for(let dy=-RADIUS; dy<=RADIUS; dy++){
    for(let dx=-RADIUS; dx<=RADIUS; dx++){
      if(dx*dx+dy*dy>RADIUS*RADIUS) continue;
      if(isBlocked(x+dx, y+dy)) return true;
    }
  }
  return false;
}

// カメラ
function camera(){
  const cx = Math.round(my.x - canvas.width/2);
  const cy = Math.round(my.y - canvas.height/2);
  return { x: Math.max(0, Math.min(world.w - canvas.width,  cx)),
           y: Math.max(0, Math.min(world.h - canvas.height, cy)) };
}

// 位置更新＋同期
let lastSync=0;
function step(){
  let vx=0, vy=0;
  if(keys.has('ArrowUp')   || keys.has('w') || keys.has('W')) vy-=1;
  if(keys.has('ArrowDown') || keys.has('s') || keys.has('S')) vy+=1;
  if(keys.has('ArrowLeft') || keys.has('a') || keys.has('A')) vx-=1;
  if(keys.has('ArrowRight')|| keys.has('d') || keys.has('D')) vx+=1;
  if(vx||vy){
    const len=Math.hypot(vx,vy); vx/=len; vy/=len;
    const nx=my.x+vx*SPEED, ny=my.y+vy*SPEED;
    if(!hits(nx,my.y)) my.x=nx;
    if(!hits(my.x,ny)) my.y=ny;
    dir = Math.abs(vx)>Math.abs(vy) ? (vx>0?'right':'left') : (vy>0?'front':'back');
  }

  const cam = camera();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(imgMap, -cam.x, -cam.y);

  // 他プレイヤー
  for(const [id,p] of Object.entries(players)){
    if(!p) continue;
    const im=spriteByDir(p.dir||'front');
    const sw=im.width*SCALE, sh=im.height*SCALE;
    const sx=Math.round(p.x - sw/2 - cam.x), sy=Math.round(p.y - sh/2 - cam.y);
    ctx.drawImage(im, sx, sy, sw, sh);
    drawName(p.name||'?', p.x - cam.x, (p.y - sh/2) - cam.y - 2, id===meId);
  }

  // 自分
  const meIm=spriteByDir(dir), mw=meIm.width*SCALE, mh=meIm.height*SCALE;
  ctx.drawImage(meIm, Math.round(my.x - mw/2 - cam.x), Math.round(my.y - mh/2 - cam.y), mw, mh);
  drawName(NAME, my.x - cam.x, (my.y - mh/2) - cam.y - 2, true);

  const now=performance.now();
  if(now-lastSync>50){ lastSync=now; update(meRef, { x: my.x, y: my.y, dir, ts: Date.now() }); }

  requestAnimationFrame(step);
}
requestAnimationFrame(step);

function drawName(name, x, y, me=false){
  ctx.font='12px system-ui, sans-serif'; ctx.textAlign='center';
  ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(x-32, y-14, 64, 16);
  ctx.fillStyle= me? '#22d3ee' : '#e2e8f0'; ctx.fillText(name, x, y-2);
}

// ===== Chat =====
const chatView=document.getElementById('chatView');
const textEl=document.getElementById('text');
const sendBtn=document.getElementById('send');
const ctxMenu=document.getElementById('ctxMenu');
let ctxTargetId=null;

function itemEl(id,m){
  const el=document.createElement('div');
  el.className='item'+(m.uid===meId?' me':'');
  el.dataset.id=id; el.dataset.uid=m.uid||'';
  el.textContent=`${m.name||'?'}: ${m.text||''}`;
  el.title=new Date(m.ts||Date.now()).toLocaleString();
  el.oncontextmenu = (e)=>{ e.preventDefault(); if(m.uid!==meId) return; ctxTargetId=id; openCtx(e.clientX,e.clientY); };
  return el;
}
function openCtx(x,y){ ctxMenu.style.display='block'; ctxMenu.style.left=x+'px'; ctxMenu.style.top=y+'px'; }
function closeCtx(){ ctxMenu.style.display='none'; ctxTargetId=null; }
addEventListener('click', ()=>closeCtx());

const chatQ=query(chatRef, limitToLast(100));
const items=new Map();
onChildAdded(chatQ, s=>{ const id=s.key, m=s.val()||{}; const el=itemEl(id,m); items.set(id,el); chatView.appendChild(el); chatView.scrollTop=chatView.scrollHeight; });
onChildChanged(chatQ, s=>{ const id=s.key, m=s.val()||{}; const old=items.get(id); if(old){ const el=itemEl(id,m); chatView.replaceChild(el,old); items.set(id,el); }});
onChildRemoved(chatQ, s=>{ const id=s.key; const el=items.get(id); if(el){ el.remove(); items.delete(id);} });

sendBtn.onclick=async()=>{ const t=textEl.value.trim(); if(!t) return; await push(chatRef,{uid:meId,name:NAME,text:t.slice(0,200),ts:Date.now()}); textEl.value=''; textEl.focus(); };
textEl.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); sendBtn.click(); } });

document.getElementById('editMsg').onclick=async()=>{ if(!ctxTargetId) return;
  const cur=items.get(ctxTargetId)?.textContent?.replace(/^.*?:\s*/,'')||'';
  const t=prompt('メッセージを編集',cur); if(t==null) return;
  await update(ref(db, `rooms/${ROOM}/chat/${ctxTargetId}`), { text:t.slice(0,200), edited:true, ts:Date.now() });
  closeCtx();
};
document.getElementById('delMsg').onclick=async()=>{ if(!ctxTargetId) return;
  await remove(ref(db, `rooms/${ROOM}/chat/${ctxTargetId}`)); closeCtx();
};

// ===== Leave =====
document.getElementById('leave').onclick=()=>{ remove(meRef).finally(()=>{ location.href='./'; }); };
addEventListener('beforeunload', ()=>{ remove(meRef); });

</script>
</body>
</html>
