<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ニコリタウン - ルーム（smooth）</title>
<style>
  :root{--bg:#0b1220;--panel2:#101826;--border:#334155;--text:#e2e8f0;--a1:#22d3ee;--a2:#06b6d4}
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;overflow:hidden}
  #game{display:block;width:100vw;height:100vh;image-rendering:pixelated}
  .hud{position:fixed;left:8px;top:8px;display:flex;gap:8px;align-items:center;z-index:20}
  .hud button{font:inherit;padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:linear-gradient(180deg,var(--a1),var(--a2));color:#06202a;font-weight:700;cursor:pointer}
  .hud .info{background:var(--panel2);border:1px solid var(--border);padding:6px 10px;border-radius:10px}
  #chatView{position:fixed;right:8px;top:8px;z-index:20;width:min(36vw,520px);max-height:55vh;overflow:auto;background:rgba(16,24,38,.85);backdrop-filter:blur(6px);border:1px solid var(--border);border-radius:12px;padding:8px}
  #chatView .item{padding:4px 6px;border-radius:8px;margin:4px 0}
  #chatView .me{background:rgba(34,211,238,.15)}
  #composer{position:fixed;left:50%;bottom:8px;transform:translateX(-50%);display:flex;gap:6px;z-index:20;background:var(--panel2);border:1px solid var(--border);border-radius:12px;padding:6px}
  #composer input{font:inherit;width:min(60vw,720px);padding:8px 10px;border:1px solid var(--border);border-radius:10px;background:#0b1220;color:#e2e8f0}
  #composer button{font:inherit;padding:8px 12px;border-radius:10px;border:1px solid var(--border);background:linear-gradient(180deg,var(--a1),var(--a2));color:#06202a;font-weight:700;cursor:pointer}
  #ctxMenu{position:fixed;z-index:50;display:none;background:#101826;border:1px solid var(--border);border-radius:10px;overflow:hidden}
  #ctxMenu button{display:block;width:180px;text-align:left;padding:8px 12px;background:transparent;border:0;color:#e2e8f0;cursor:pointer}
  #ctxMenu button:hover{background:#1b2540}
</style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud">
    <button id="leave">退室</button>
    <div class="info">ルーム: <span id="roomId">-</span>／ 自分: <span id="who">-</span>／ 人数: <span id="count">0</span></div>
  </div>

  <div id="chatView"></div>
  <div id="composer">
    <input id="text" placeholder="メッセージ… (Enterで送信)" maxlength="200" />
    <button id="send">送信</button>
  </div>
  <div id="ctxMenu">
    <button id="editMsg">編集</button>
    <button id="delMsg">削除</button>
  </div>

<script type="module">
/* --------------------- 調整パラメータ --------------------- */
const SCALE = 1.5;            // 小さいほど視野広い
const SPEED_PPS = 300;        // 自分の速度 (px/sec)
const RADIUS = 10;            // 当たり半径
const PLAYER_INTERP = 12;     // 他プレイヤー追従（8〜16）
const CAM_INTERP = 10;        // カメラ追従（6〜14）
const SYNC_MS = 50;           // 位置同期の間隔

/* ------------------------ Firebase ------------------------ */
import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js';
import { getAuth, signInAnonymously } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js';
import { getDatabase, ref, onDisconnect, set, update, remove, onValue, push, limitToLast, query,
         onChildAdded, onChildChanged, onChildRemoved } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js';

const firebaseConfig = {
  apiKey: 'AIzaSyCy3P-HQhfd8-zpPUJ5YANxwRMuTCjFFAQ',
  authDomain: 'nikori-town.firebaseapp.com',
  databaseURL: 'https://nikori-town-default-rtdb.asia-southeast1.firebasedatabase.app',
  projectId: 'nikori-town',
  storageBucket: 'nikori-town.firebasestorage.app',
  messagingSenderId: '836836010871',
  appId: '1:836836010871:web:74ae40cb16ee6d50368f72'
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db   = getDatabase(app);

/* ------------------------ URL params ---------------------- */
const u = new URL(location.href);
const ROOM = (u.searchParams.get('room')||'room-001').toLowerCase();
const NAME = u.searchParams.get('name')||'guest';
document.getElementById('roomId').textContent = ROOM;
document.getElementById('who').textContent    = NAME;

/* ------------------------- Assets ------------------------- */
function loadImage(src){ return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=src; }); }
const imgMap   = await loadImage('./map_1.png');
const imgMask  = await loadImage('./atarihantei.png'); // 赤=壁
const imgFront = await loadImage('./nikorihito_dot_front.png');
const imgBack  = await loadImage('./nikorihito_dot_behind.png');
const imgLeft  = await loadImage('./nikorihito_dot_left.png');
const imgRight = await loadImage('./nikorihito_dot_right.png');

/* -------------------- Canvas & Camera --------------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false; // にじみ防止
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener('resize', resize); resize();

const world = { w: imgMap.width, h: imgMap.height };

/* -------------------- Collision Mask --------------------- */
const maskC = new OffscreenCanvas(imgMask.width, imgMask.height);
const maskX = maskC.getContext('2d');
maskX.drawImage(imgMask, 0, 0);
function isBlocked(x,y){
  if(x<0||y<0||x>=world.w||y>=world.h) return true;
  const d = maskX.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
  const r=d[0], g=d[1], b=d[2], a=d[3];
  if (a < 10) return false;
  return (r >= 180 && g <= 80 && b <= 80); // 赤
}
function hits(x,y){
  if(x<0||y<0||x>=world.w||y>=world.h) return true;
  for(let dy=-RADIUS; dy<=RADIUS; dy++){
    for(let dx=-RADIUS; dx<=RADIUS; dx++){
      if(dx*dx+dy*dy>RADIUS*RADIUS) continue;
      if(isBlocked(x+dx, y+dy)) return true;
    }
  }
  return false;
}
function safeSpawn(maxTry=500){
  for(let i=0;i<maxTry;i++){
    const x = Math.random()*(world.w-64)+32;
    const y = Math.random()*(world.h-64)+32;
    if(!hits(x,y)) return {x,y};
  }
  const cx=world.w/2, cy=world.h/2;
  for(let r=0;r<400;r+=8){
    for(let a=0;a<Math.PI*2;a+=Math.PI/8){
      const x=cx+Math.cos(a)*r, y=cy+Math.sin(a)*r;
      if(!hits(x,y)) return {x,y};
    }
  }
  return {x:cx, y:cy};
}

/* ---------------------- Game State ----------------------- */
let dir = 'front';
const keys = new Set();
let my = Object.assign({dir, name: NAME, ts: Date.now()}, safeSpawn());

const playersRef = ref(db, `rooms/${ROOM}/players`);
const meId  = crypto.randomUUID();
const meRef = ref(db, `rooms/${ROOM}/players/${meId}`);
const chatRef = ref(db, `rooms/${ROOM}/chat`);

signInAnonymously(auth).catch(()=>{});

await set(meRef, { name: NAME, x: my.x, y: my.y, dir: my.dir, ts: Date.now() });
onDisconnect(meRef).remove();

/* 生データと可視化用ゴースト（補間先） */
let players = {};
const ghosts = {}; // id -> {x,y,dir,name}
onValue(playersRef, snap=>{
  players = snap.val()||{};
  document.getElementById('count').textContent = Object.keys(players).length;
  for(const [id,p] of Object.entries(players)){
    if(!ghosts[id] && p) ghosts[id] = { x:p.x, y:p.y, dir:p.dir, name:p.name };
  }
});

/* 入力 */
addEventListener('keydown', e=>{
  const k=e.key;
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(k)) e.preventDefault();
  keys.add(k);
});
addEventListener('keyup', e=>{ keys.delete(e.key); });

function spriteByDir(d){ return d==='back'?imgBack: d==='left'?imgLeft: d==='right'?imgRight: imgFront; }

/* カメラ補間 */
let camX = 0, camY = 0;
function camera(dt){
  const tx = Math.round(my.x - canvas.width/2);
  const ty = Math.round(my.y - canvas.height/2);
  const k  = Math.min(1, dt * CAM_INTERP);
  camX += (tx - camX) * k;
  camY += (ty - camY) * k;
  camX = Math.max(0, Math.min(world.w - canvas.width,  camX));
  camY = Math.max(0, Math.min(world.h - canvas.height, camY));
  return { x: camX, y: camY };
}

/* --------------------- Main Loop ------------------------- */
let lastSync = 0;
let lastT = performance.now();
function step(now){
  const dt = Math.min(0.033, (now - lastT) / 1000);
  lastT = now;

  // 入力→移動（delta-time）
  let vx=0, vy=0;
  if(keys.has('ArrowUp')   || keys.has('w') || keys.has('W')) vy-=1;
  if(keys.has('ArrowDown') || keys.has('s') || keys.has('S')) vy+=1;
  if(keys.has('ArrowLeft') || keys.has('a') || keys.has('A')) vx-=1;
  if(keys.has('ArrowRight')|| keys.has('d') || keys.has('D')) vx+=1;

  if(vx||vy){
    const len=Math.hypot(vx,vy); vx/=len; vy/=len;
    const s = SPEED_PPS * dt;
    const nx = my.x + vx*s, ny = my.y + vy*s;
    if(!hits(nx, my.y)) my.x = nx;
    if(!hits(my.x, ny)) my.y = ny;
    dir = Math.abs(vx)>Math.abs(vy) ? (vx>0?'right':'left') : (vy>0?'front':'back');
  }

  // 補間して描画
  const cam = camera(dt);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(imgMap, -cam.x, -cam.y);

  // 他プレイヤー（補間）
  const kInterp = Math.min(1, dt * PLAYER_INTERP);
  for(const [id,p] of Object.entries(players)){
    if(!p || id===meId) continue;
    const g = (ghosts[id] ||= { x:p.x, y:p.y, dir:p.dir, name:p.name });
    g.x += (p.x - g.x) * kInterp;
    g.y += (p.y - g.y) * kInterp;
    g.dir = p.dir || g.dir; g.name = p.name || g.name;

    const im = spriteByDir(g.dir||'front');
    const sw = im.width*SCALE, sh = im.height*SCALE;
    const sx = Math.round(g.x - sw/2 - cam.x), sy = Math.round(g.y - sh/2 - cam.y);
    ctx.drawImage(im, sx, sy, sw, sh);
    drawName(g.name||'?', g.x - cam.x, (g.y - sh/2) - cam.y - 2, false);
  }

  // 自分
  const meIm = spriteByDir(dir), mw = meIm.width*SCALE, mh = meIm.height*SCALE;
  ctx.drawImage(meIm, Math.round(my.x - mw/2 - cam.x), Math.round(my.y - mh/2 - cam.y), mw, mh);
  drawName(NAME, my.x - cam.x, (my.y - mh/2) - cam.y - 2, true);

  // 位置同期（帯域を抑えて20fps）
  if(now-lastSync>SYNC_MS){ lastSync=now; update(meRef, { x: my.x, y: my.y, dir, ts: Date.now() }); }

  requestAnimationFrame(step);
}
requestAnimationFrame(step);

function drawName(name, x, y, me=false){
  ctx.font='12px system-ui, sans-serif'; ctx.textAlign='center';
  ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(x-32, y-14, 64, 16);
  ctx.fillStyle= me? '#22d3ee' : '#e2e8f0'; ctx.fillText(name, x, y-2);
}

/* ------------------------ Chat --------------------------- */
const chatView=document.getElementById('chatView');
const textEl=document.getElementById('text');
const sendBtn=document.getElementById('send');
const ctxMenu=document.getElementById('ctxMenu');
let ctxTargetId=null;

const chatQ=query(chatRef, limitToLast(100));
const items=new Map();
function itemEl(id,m){
  const el=document.createElement('div');
  el.className='item'+(m.uid===meId?' me':'');
  el.dataset.id=id; el.dataset.uid=m.uid||'';
  el.textContent=`${m.name||'?'}: ${m.text||''}`;
  el.title=new Date(m.ts||Date.now()).toLocaleString();
  el.oncontextmenu=(e)=>{ e.preventDefault(); if(m.uid!==meId) return; ctxTargetId=id; openCtx(e.clientX,e.clientY); };
  return el;
}
onChildAdded(chatQ, s=>{ const id=s.key, m=s.val()||{}; const el=itemEl(id,m); items.set(id,el); chatView.appendChild(el); chatView.scrollTop=chatView.scrollHeight; });
onChildChanged(chatQ, s=>{ const id=s.key, m=s.val()||{}; const old=items.get(id); if(old){ const el=itemEl(id,m); chatView.replaceChild(el,old); items.set(id,el); }});
onChildRemoved(chatQ, s=>{ const id=s.key; const el=items.get(id); if(el){ el.remove(); items.delete(id);} });

sendBtn.onclick=async()=>{ const t=textEl.value.trim(); if(!t) return; await push(chatRef,{uid:meId,name:NAME,text:t.slice(0,200),ts:Date.now()}); textEl.value=''; textEl.focus(); };
textEl.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); sendBtn.click(); } });

function openCtx(x,y){ ctxMenu.style.display='block'; ctxMenu.style.left=x+'px'; ctxMenu.style.top=y+'px'; }
function closeCtx(){ ctxMenu.style.display='none'; ctxTargetId=null; }
addEventListener('click', ()=>closeCtx());

document.getElementById('editMsg').onclick=async()=>{ if(!ctxTargetId) return;
  const cur=items.get(ctxTargetId)?.textContent?.replace(/^.*?:\s*/,'')||'';
  const t=prompt('メッセージを編集',cur); if(t==null) return;
  await update(ref(db, `rooms/${ROOM}/chat/${ctxTargetId}`), { text:t.slice(0,200), edited:true, ts:Date.now() });
  closeCtx();
};
document.getElementById('delMsg').onclick=async()=>{ if(!ctxTargetId) return;
  await remove(ref(db, `rooms/${ROOM}/chat/${ctxTargetId}`)); closeCtx();
};

/* --------------------- Leave handling -------------------- */
document.getElementById('leave').onclick=()=>{ remove(meRef).finally(()=>{ location.href='./'; }); };
addEventListener('beforeunload', ()=>{ remove(meRef); });
</script>
</body>
</html>
