<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ニコリタウン - ルーム</title>
  <style>
    html, body { margin:0; height:100%; }
    body { display:grid; grid-template-rows: 1fr auto; background:#0b1220; color:#e2e8f0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; }
    #game { position:relative; overflow:hidden; }
    #canvas { display:block; width:100%; height:100%; background:black; }
    #hud {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(17,24,39,.75);
      border: 1px solid rgba(148,163,184,.25);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
    }
    #chatBar {
      display:flex;
      gap:8px;
      padding:10px;
      background:#0f172a;
      border-top:1px solid #111827;
    }
    #msg { flex:1; padding:10px 12px; border-radius:10px; border:1px solid #334155; background:#0b1220; color:#e2e8f0; }
    #send { padding:10px 16px; border-radius:10px; border:0; background:linear-gradient(180deg,#22d3ee,#06b6d4); color:#06202a; font-weight:700; }
    .bubble {
      position:absolute;
      padding:6px 8px;
      background:#111827;
      border:1px solid rgba(255,255,255,.12);
      border-radius:8px;
      font-size:12px;
      transform: translate(-50%, -120%);
      pointer-events:none;
      white-space:nowrap;
      max-width: 220px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="canvas"></canvas>
    <div id="hud">接続中…</div>
  </div>
  <div id="chatBar">
    <input id="msg" placeholder="近くの人に話しかける…" />
    <button id="send">送信</button>
  </div>

  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <script>
    // === 1) ルーム情報（URLパラメータ） ===========================
    const params = new URLSearchParams(location.search);
    const ROOM_ID = params.get('room') || 'demo';
    const PLAYER_NAME = params.get('name') || 'guest';
    const MODE = params.get('mode') || 'join';

    // === 2) Firebase 初期化（未設定ならローカル同期待機） =========
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
      databaseURL: "https://YOUR_PROJECT_ID-default-rtdb.firebaseio.com",
      projectId: "YOUR_PROJECT_ID",
      storageBucket: "YOUR_PROJECT_ID.appspot.com",
      messagingSenderId: "SENDER_ID",
      appId: "APP_ID"
    };
    const USE_BROADCAST = (firebaseConfig.apiKey || "").startsWith("YOUR_");

    let db = null, roomRef = null, playersRef = null, chatRef = null;
    let bcPlayers = null, bcChat = null;

    if (!USE_BROADCAST) {
      firebase.initializeApp(firebaseConfig);
      db = firebase.database();
      roomRef = db.ref(`/rooms/${ROOM_ID}`);
      playersRef = roomRef.child('players');
      chatRef = roomRef.child('chat');
    } else {
      // BroadcastChannel fallback（同一PC/同一ブラウザの複数タブで動作）
      bcPlayers = new BroadcastChannel(`ntown-${ROOM_ID}-players`);
      bcChat = new BroadcastChannel(`ntown-${ROOM_ID}-chat`);
    }

    // === 3) キャンバス準備 ========================================
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    function fitCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight - 54; }
    window.addEventListener('resize', fitCanvas);
    fitCanvas();

    // 画像ロード
    const mapImage = new Image();
    const collisionImage = new Image();
    const sprites = {
      up: new Image(),
      down: new Image(),
      left: new Image(),
      right: new Image()
    };
    mapImage.src = 'map_1.png';
    collisionImage.src = 'atarihantei.png';
    sprites.up.src = 'nikorihito_dot_behind.png';
    sprites.down.src = 'nikorihito_dot_front.png';
    sprites.left.src = 'nikorihito_dot_left.png';
    sprites.right.src = 'nikorihito_dot_right.png';

    // 衝突判定用のオフスクリーン
    const colCanvas = document.createElement('canvas');
    const colCtx = colCanvas.getContext('2d');

    const me = {
      id: Math.random().toString(36).slice(2, 9),
      name: PLAYER_NAME,
      x: 900, y: 600,
      dir: 'down',
      speed: 3.2
    };
    const camera = { x:0, y:0, w:canvas.width, h:canvas.height };
    const keys = {};
    addEventListener('keydown', e => { keys[e.key] = true; });
    addEventListener('keyup', e => { keys[e.key] = false; });

    // 他プレイヤー
    const others = new Map(); // id -> {x,y,dir,name,ts}

    const PROXIMITY = 180; // 近接会話の半径(px)
    const hud = document.getElementById('hud');

    // === 4) 接続セットアップ =====================================
    let myRef = null;
    if (!USE_BROADCAST) {
      // Firebase版
      myRef = playersRef.push();
      me.id = myRef.key;
      myRef.onDisconnect().remove();
      if (MODE === 'create') roomRef.child('meta').update({ createdAt: Date.now() });

      playersRef.on('child_added', snap => { const p = snap.val(); if (snap.key === me.id) return; others.set(snap.key, p); });
      playersRef.on('child_changed', snap => { if (snap.key === me.id) return; others.set(snap.key, snap.val()); });
      playersRef.on('child_removed', snap => { others.delete(snap.key); const b = document.getElementById('bub-' + snap.key); if (b) b.remove(); });

      chatRef.limitToLast(32).on('child_added', snap => {
        const m = snap.val();
        const dist = Math.hypot((m.x ?? 0) - me.x, (m.y ?? 0) - me.y);
        if (dist <= PROXIMITY) showBubble(m.id, `${m.name}: ${m.text}`);
      });

      window.addEventListener('beforeunload', () => { try { myRef.remove(); } catch(e){} });
    } else {
      // BroadcastChannel版
      // 受信: プレイヤー更新
      bcPlayers.onmessage = e => {
        const m = e.data;
        if (!m || !m.type) return;
        if (m.type === 'player' && m.id !== me.id) {
          others.set(m.id, { name:m.name, x:m.x, y:m.y, dir:m.dir, ts:Date.now() });
        }
        if (m.type === 'leave') {
          others.delete(m.id);
          const b = document.getElementById('bub-' + m.id); if (b) b.remove();
        }
      };
      // 受信: チャット
      bcChat.onmessage = e => {
        const m = e.data;
        if (!m || m.type !== 'chat') return;
        const dist = Math.hypot((m.x ?? 0) - me.x, (m.y ?? 0) - me.y);
        if (dist <= PROXIMITY) showBubble(m.id, `${m.name}: ${m.text}`);
      };
      // 離脱通知
      window.addEventListener('beforeunload', () => {
        bcPlayers.postMessage({ type:'leave', id:me.id });
      });
    }

    // === 5) チャット送信 ==========================================
    function sendChat(text) {
      text = (text || '').trim();
      if (!text) return;
      const payload = { id: me.id, name: me.name, text, x: me.x, y: me.y, ts: Date.now() };
      if (!USE_BROADCAST) {
        chatRef.push(payload);
      } else {
        bcChat.postMessage({ type:'chat', ...payload });
      }
    }

    // ふきだし表示
    function showBubble(id, text) {
      let el = document.getElementById('bub-' + id);
      if (!el) {
        el = document.createElement('div');
        el.className = 'bubble';
        el.id = 'bub-' + id;
        document.getElementById('game').appendChild(el);
      }
      el.textContent = text;
      clearTimeout(el._t);
      el._t = setTimeout(() => el.remove(), 3000);
    }
    // === 6) 衝突判定 ==============================================
    // プレイヤーの当たり半径（足元付近だけ判定）
    const COLLISION_RADIUS = 10; // px
    const FOOT_OFFSET_Y = 8;     // 画像中心より少し下（足元）

    function redBlocked(px, py) {
      if (px < 0 || py < 0 || px >= colCanvas.width || py >= colCanvas.height) return true;
      const d = colCtx.getImageData(px, py, 1, 1).data;
      // 「赤優勢」を障害物扱い（atarihantei.png の赤ブロック）
      return (d[3] > 128) && (d[0] > 200) && (d[1] < 80) && (d[2] < 80);
    }

    function isBlocked(x, y) {
      // 足元を中心に円周の数点をチェック
      const cx = Math.floor(x);
      const cy = Math.floor(y + FOOT_OFFSET_Y);
      const checks = 8;
      for (let i=0; i<checks; i++) {
        const ang = (Math.PI * 2 * i) / checks;
        const px = Math.floor(cx + Math.cos(ang) * COLLISION_RADIUS);
        const py = Math.floor(cy + Math.sin(ang) * COLLISION_RADIUS);
        if (redBlocked(px, py)) return true;
      }
      // 中心も念のため
      if (redBlocked(cx, cy)) return true;
      return false;
    }


    // === 7) ループ ================================================
    function update() {
      let nx = me.x, ny = me.y;
      if (keys['ArrowUp'] || keys['w']) { ny -= me.speed; me.dir = 'up'; }
      if (keys['ArrowDown'] || keys['s']) { ny += me.speed; me.dir = 'down'; }
      if (keys['ArrowLeft'] || keys['a']) { nx -= me.speed; me.dir = 'left'; }
      if (keys['ArrowRight'] || keys['d']) { nx += me.speed; me.dir = 'right'; }
      if (!isBlocked(nx, ny)) { me.x = nx; me.y = ny; }

      // カメラ（マップよりキャンバスが大きい場合に対応）
      camera.w = canvas.width; camera.h = canvas.height;
      const sw = Math.min(camera.w, mapImage.width || camera.w);
      const sh = Math.min(camera.h, mapImage.height || camera.h);
      camera.x = Math.max(0, Math.min(me.x - sw/2, Math.max(0, (mapImage.width||sw) - sw)));
      camera.y = Math.max(0, Math.min(me.y - sh/2, Math.max(0, (mapImage.height||sh) - sh)));
      camera.sw = sw; camera.sh = sh;

      // 位置送信（間引き）
      const now = performance.now();
      if (!update._last || now - update._last > 80) {
        if (!USE_BROADCAST) {
          myRef && myRef.set({ name: me.name, x: me.x, y: me.y, dir: me.dir, ts: Date.now() });
        } else {
          bcPlayers.postMessage({ type:'player', id:me.id, name:me.name, x:me.x, y:me.y, dir:me.dir });
        }
        update._last = now;
      }

      // BroadcastChannel版のstale掃除
      if (USE_BROADCAST) {
        const deadline = Date.now() - 5000;
        for (const [id, p] of [...others]) {
          if ((p.ts || 0) < deadline) {
            others.delete(id);
            const b = document.getElementById('bub-' + id); if (b) b.remove();
          }
        }
      }

      // 吹き出し位置追従
      for (const [id, p] of others) positionBubble(id, p);
      positionBubble(me.id, me);
    }

    function positionBubble(id, p) {
      const el = document.getElementById('bub-' + id);
      if (!el) return;
      const sx = (p.x - camera.x);
      const sy = (p.y - camera.y);
      el.style.left = sx + 'px';
      el.style.top  = sy + 'px';
    }

    function draw() {
      ctx.clearRect(0,0,canvas.width, canvas.height);
      // マップ（ソース矩形をマップ内に制限）
      ctx.drawImage(mapImage, camera.x, camera.y, camera.sw, camera.sh, 0, 0, canvas.width, canvas.height);

      // 他プレイヤー
      for (const [id, p] of others) {
        const sp = sprites[p.dir] || sprites.down;
        const sx = p.x - camera.x - 32;
        const sy = p.y - camera.y - 32;
        ctx.drawImage(sp, sx, sy, 64, 64);
        ctx.font = '12px system-ui';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.fillText(p.name || 'player', sx + 32, sy + 72);
      }

      // 自分
      const sp = sprites[me.dir] || sprites.down;
      ctx.drawImage(sp, me.x - camera.x - 32, me.y - camera.y - 32, 64, 64);
      ctx.textAlign = 'center';
      ctx.fillText(me.name, me.x - camera.x, me.y - camera.y + 40);
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // === 8) 画像ロード完了後に開始 ===============================
    function loadAll(callback) {
      let loaded = 0;
      const total = 6;
      function done(){ if (++loaded === total) callback(); }
      mapImage.onload = done;
      collisionImage.onload = () => {
        colCanvas.width = collisionImage.width;
        colCanvas.height = collisionImage.height;
        colCtx.drawImage(collisionImage, 0, 0);
        done();
      };
      sprites.up.onload = done; sprites.down.onload = done; sprites.left.onload = done; sprites.right.onload = done;
    }
    loadAll(() => {
      const modeLabel = USE_BROADCAST ? 'ローカル（同一ブラウザ）' : 'オンライン';
      document.getElementById('hud').textContent = `ルーム: ${ROOM_ID}　|　名前: ${PLAYER_NAME}　|　同期: ${modeLabel}`;
      loop();
    });

    // === 9) チャット送信 UI =====================================
    const msg = document.getElementById('msg');
    const send = document.getElementById('send');
    send.onclick = () => { sendChat(msg.value); msg.value=''; msg.focus(); };
    msg.addEventListener('keydown', e => { if (e.key === 'Enter') { send.click(); }});
  </script>
</body>
</html>
